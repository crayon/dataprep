import warnings
from typing import Any, Dict, List, Optional, Union, Tuple
import copy

import pandas as pd
from bokeh.resources import INLINE
from jinja2 import Environment, PackageLoader

# from ..configs import Config
from ..eda.configs import Config
# from .formatter import format_report
from ..eda.create_report.formatter import format_report
# from .report import Report
from ..eda.create_report.report import Report
# from .custom import CustomSection, CustomPlotly, CustomImage, add_section
from .custom_objects import CustomSection

ENV_LOADER = Environment(
    loader=PackageLoader("dataprep", "custom/templates"),
)


def create_custom_report(
    df: Optional[pd.DataFrame] = None,
    *,
    config: Optional[Dict[str, Any]] = None,
    display: Optional[List[str]] = None,
    title: Optional[str] = "DataPrep Report",
    mode: Optional[str] = "basic",
    progress: bool = True,
    context: Optional[Dict[str, Any]] = None,
    returnreport: bool = True,
    returncontext: bool = False,
    customsections: Optional[Union[CustomSection, List[CustomSection]]] = None,
    warn: bool = False
) -> Report:
    """
    TODO Update this to add custom features
    This function is to generate and render element in a report object.

    Parameters
    ----------
    df
        The DataFrame for which data are calculated. Must be provided if `context` is None.
    config
        A dictionary for configuring the visualizations
        E.g. config={"hist.bins": 20}
    display
        The list that contains the names of plots user wants to display,
        E.g. display =  ["bar", "hist"]
        Without user's specifications, the default is "auto"
    title: Optional[str], default "DataPrep Report"
        The title of the report, which will be shown on the navigation bar.
    mode: Optional[str], default "basic"
        This controls what type of report to be generated.
        Currently only the 'basic' is fully implemented.
    progress
        Whether to show the progress bar.
    context
        context dictionary of the format generated by this function
    returnreport
        Whether to return the Report object created by this function
    returncontext
        Whether to return the context dictionary used to create the report
    customsections
        Custom sections to add to the end of the report
    warn
        If False, specific warnings are suppressed. See `_suppress_warnings()` for details.
    Examples
    --------
    >>> import pandas as pd
    >>> from dataprep.eda import create_report
    >>> df = pd.read_csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv')
    >>> report = create_report(df)
    >>> report # show report in notebook
    >>> report.save('My Fantastic Report') # save report to local disk
    >>> report.show_browser() # show report in the browser
    """
    if not warn:
        _suppress_warnings()
    if not context:
        cfg = Config.from_dict(display, config)
        context = {
            "resources": INLINE.render(),
            "title": title,
            "components": format_report(df, cfg, mode, progress),
        }

    if customsections:
        context["components"]["has_customsections"] = True
        if not isinstance(customsections, list):
            customsections = [customsections]
        for section in customsections:
            context = add_section(context, section)

    if (not returnreport) and returncontext:
        return context

    template_base = ENV_LOADER.get_template("base_custom.html")
    report = template_base.render(context=context)

    if returnreport and returncontext:
        return Report(report), context
    elif returnreport and (not returncontext):
        return Report(report)
    else:
        return None


def create_empty_context():
    """ Creates an nested dict in the same structure as returned by `create_report()`"""
    empty_components = {
        'overview_insights': None,
        'overview': None,
        'has_overview': None,
        'variables': None,
        'has_variables': None,
        'has_interaction': None,
        'interactions': None,
        'has_correlation': None,
        'correlation_names': None,
        'correlations': None,
        'has_missing': None,
        'missing': None,
        'missing_tabs': None
    }
    return {
        "resources": INLINE.render(),
        "title": None,
        "components": empty_components,
    }


def create_context(config):
    """ Create a context from a YAML file"""

    # If config is a dict, then work witht the dict
    # if a string, load file as YAML into dict then work with dict

    # TODO
    # Create empty context
    # Load YAML
    # Process arguments in YAML one by one to add to context
    # return context
    pass
    

def add_section(context: Dict, section: Union[CustomSection, List[CustomSection]]) -> Dict:
    """ Adds one or more custom sections to a context dictionary """

    context["components"]["has_customsections"]=True
    if not isinstance(section, list):
        section = [section]
    try:
        context["components"]["customsections"]+=section
    except KeyError:
        context["components"]["customsections"]=section
    return context


def reorder_sections(
    context: Dict,
    order: Union[List[int], Tuple[int], List[str], Tuple[str]]
) -> Dict:
    """ Reorders custom sections.
        context
            Dict as created by `create_empty_context`.
        order
            A zero-indexed list-like of section positions.
            Duplicated values are allowed but not recommended. It will cause duplication of
            sections in the returned context which might not render correctly.
    """
    c = copy.deepcopy(context)
    customsections = c["components"]["customsections"]
    if len(customsections) != len(order):
        msg = (
            "`customsections` and `order` must be the same length. "
            f"Got {len(customsections)} custom sections and `order` of length {len(order)}."
        )
        raise IndexError(msg)

    print(order[0])
    print(type(order[0]))
    if isinstance(order[0], int):
        customsections = [customsections[i] for i in order]
    else:
        raise TypeError(f"`order` must be a list-like of int. Got {type(order[0])}.")
    
    # TODO
    # elif isinstance(order[0], str):
    #     titles = [cs.title for cs in customsections]
    #     index_order = [titles.index(title) for title in order]
    #     customsections = [customsections[i] for i in index_order]
    c["components"]["customsections"] = customsections
    return c


def add_title(context: Dict, title: str) -> Dict:
    """ Adds a title to a context dictionary """
    context["title"] = title
    return context


def _suppress_warnings() -> None:
    """
    suppress warnings in create_report
    """
    # ignore these specific FutureWarning in dask
    warnings.filterwarnings(
        "ignore",
        "The default value of regex will change from True to False in a future version",
        category=FutureWarning,
        module="dask",
    )
    warnings.filterwarnings(
        "ignore",
        "Boolean inputs to the `inclusive` argument are deprecated infavour of `both` or `neither`.",
        category=FutureWarning,
        module="dask",
    )

    
